Студенты: Адамантис, Безуглый, Дзень, Кипкало, Кочерга, Маглюй, Мелентьев, Примас, Хайбуллин

Вопрос №1: Многопоточные вычисления в Python. Ограничения Global Interpreter Lock (GIL).
Python предлагает модуль _thread для распараллеливания вычислений, также можно стартовать новые процессы,
 и (хотя это не совсем параллелизм) есть еще асинхронность. Главное отличие треда от процесса -
 тред - это не полнофункциональное программное решение, а какой-то обьект, который можно вызвать. 
 Таким обьектом моожет послужиить обьект, лямбда-функция, просто функция (генератор, итератор). 

 Основное благо и проблема тредов - это общий доступ к ресурсоам в одно и то же время. Таким образом, 
 если запись в один и тот же обьект происходит параллельно, это может сломать ход программы и результаты
 (например, если это файл). Поэтому треды рекомендуют использовать в первую очередь для вещей, которые не зависят друг 
 от друга. Так, например, можно делать параллельный reduce, если операция коммутативная. 

 Global Interpreter Lock удостоверивается, что всегда для одного процессса и его тредов выполнение идет в рамках одного
 ядра процессора. Это необходимо для избежания таких ошибок, которые язык не смог бы котролировать.

Вопрос №2: Анонимные функции. Ограничения лямбда-выражений в Python (примеры кода).
Анонимные функции, или лямбда-выражения, это еще один способ ввести функцию в программу, у него есть некоторые характерные
отличия. Во-первых, лямбда-выражения - это не statement, a expression. Они не вычисляются при создании.
Это просто обьект, который можно вызвать через () и присвоить в переменную 
lambda arg1, ... argN: (return statement)
Самая базовая и знаменитая лямбда: 
  Identity = lambda x: x

Схожесть с обычными функциями еще и в том, что лямбды создают свой scope. Их можно вкладывать друг в друга. 
Лямбды нужны для имплементации различных инструментов парадигмы функционального программирования, что есть хорошо для работы 
со списками, или для создания новых функций через каррирование и композицию:

adder = lambda start: lambda x: x + start 
a1 = adder(0)
a1(5) // 0 + 5 = 5

Несмотря на все удобство, лямбда выражения стоит применять в ограниченном числе случаев, например, при указании параметра для
другой функции (кстати говоря, функции, которые принимают другие функции как аргумент, называются функциями первого класса).
arr = [...]
arr = list(map(arr, lambda x: x*2))
 Таким образом, удобнее всего их использовать при обработке списков и как коллбеки. Также, поскольку это средство ФП, то
 получать поведение как у мутабельных обьектов нельза, присвоения внутри ограничены.

